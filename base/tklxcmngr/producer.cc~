
#include "producer.h"
#define IP 1
#define NOT_IP 2
#define NOT_SUPPORTED -1
#define TRUE 1
#define FALSE 0

char *dev_name;
char dev_ip_address[100];
char errbuf[PCAP_ERRBUF_SIZE];
struct sockaddr_in source,dest;
char src_ip[100];
char dst_ip[100];
struct timeval tv;


static unsigned short compute_checksum(unsigned short *addr, unsigned int count) {

	  register unsigned long sum = 0;
	  while (count > 1) {
		sum += * addr++;
	        count -= 2;
	  }

	  //if any bytes left, pad the bytes and add
	  if(count > 0) {
	    sum += ((*addr)&htons(0xFF00));
	  }

	  //Fold sum to 16 bits: add carrier to result
	  while (sum>>16) {
	      sum = (sum & 0xffff) + (sum >> 16);
	  }

	  //one's complement
	  sum = ~sum;

	  return ((unsigned short)sum);

}

/* set ip checksum of a given ip header*/

void compute_ip_checksum(struct iphdr* iphdrp){

  	iphdrp->check = 0;
	iphdrp->check = compute_checksum((unsigned short*)iphdrp, iphdrp->ihl<<2);

}

/* Compute checksum for count bytes starting at addr, using one's complement of one's complement sum*/
/* set tcp checksum: given IP header and tcp segment */

void compute_tcp_checksum(struct iphdr *pIph, unsigned short *ipPayload, FILE* fp) {

	register unsigned long sum = 0;
	unsigned short tcpLen = ntohs(pIph->tot_len) - (pIph->ihl<<2);
	struct tcphdr *tcphdrp = (struct tcphdr*)(ipPayload);

	//add the pseudo header 
	//the source ip
	sum += (pIph->saddr>>16)&0xFFFF;
	sum += (pIph->saddr)&0xFFFF;
	//the dest ip
	sum += (pIph->daddr>>16)&0xFFFF;
	sum += (pIph->daddr)&0xFFFF;
	//protocol and reserved: 6
	sum += htons(IPPROTO_TCP);
	//the length
	sum += htons(tcpLen);

	//add the IP payload
	//initialize checksum to 0

	tcphdrp->check = 0;

	while (tcpLen > 1) {
	        sum += * ipPayload++;
	        tcpLen -= 2;
	}

	//if any bytes left, pad the bytes and add
	if(tcpLen > 0) {
        //printf("+++++++++++padding, %d\n", tcpLen);
	       sum += ((*ipPayload)&htons(0xFF00));
        }

    	//Fold 32-bit sum to 16 bits: add carrier to result

	while (sum>>16) {
          sum = (sum & 0xffff) + (sum >> 16);
	}
	
        sum = ~sum;

	//set computation result

	tcphdrp->check = (unsigned short)sum;

}

/* set tcp checksum: given IP header and UDP datagram */

void compute_udp_checksum(struct iphdr *pIph, unsigned short *ipPayload,FILE* fp) {

    register unsigned long sum = 0;
    struct udphdr *udphdrp = (struct udphdr*)(ipPayload);
    unsigned short udpLen = htons(udphdrp->len);
    fprintf(fp,"Udp len = %d\n",udpLen);



    //add the pseudo header 
    //the source ip
    sum += (pIph->saddr>>16)&0xFFFF;
    sum += (pIph->saddr)&0xFFFF;

    //the dest ip
    sum += (pIph->daddr>>16)&0xFFFF;
    sum += (pIph->daddr)&0xFFFF;

    //protocol and reserved: 17
    sum += htons(IPPROTO_UDP);

    //the length
    sum += udphdrp->len; 

    //add the IP payload
    //initialize checksum to 0

    udphdrp->check = 0;
    while (udpLen > 1) {
        sum += * ipPayload++;
        udpLen -= 2;
    }

    //if any bytes left, pad the bytes and add

    if(udpLen > 0) {
        sum += ((*ipPayload)&htons(0xFF00));
    }

    while (sum>>16) {
         sum = (sum & 0xffff) + (sum >> 16);
    }
    sum = ~sum;
    fprintf(fp,"UDF Checksum = %d\n",(unsigned short)sum);

    //set computation result
    udphdrp->check = ((unsigned short)sum == 0x0000)?0xFFFF:(unsigned short)sum;

}


void print_packet(u_char * s,int size,FILE * fp){

    const u_char * ptr = s;
    int i = 0;
    fprintf(fp,"Packet :");
    for(i = 0; i < size; i++)
    {
    	fprintf(fp,"%02x",*ptr);
	++ptr;
    }
    fprintf(fp,"\n");

}
int packet_hash(u_char * s,int size)
{

    //http://stackoverflow.com/questions/114085/fast-string-hashing-algorithm-with-low-collision-rates-with-32-bit-integer
    int hash = 0;
    u_char * ptr = s;
    int i = 0;
    
    for(i = 0; i < size; i++)
    {
    	hash += *ptr;
    	hash += (hash << 10);
    	hash ^= (hash >> 6);

        ++ptr;
    }

    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);


    return hash;
}

int get_ip_addresses(const u_char * Buffer, int Size)
{
    
    unsigned short iphdrlen;
         
    struct iphdr *iph; 
    struct ether_header * eptr = (struct ether_header *) Buffer;
    u_short ether_type    = ntohs(eptr->ether_type);
    int dstIPAddr_offset = 0;
    int srcIPAddr_offset = 0;
    int ether_offset = 0;
    u_char* ptrToIPAddr;
    unsigned int dstIP;
    int is_IP = 0;

    u_char* ptrToSrcIPAddr;
    unsigned int srcIP;


    switch(ether_type){

	case ETHERTYPE_IP : 	ether_offset = 14;
				dstIPAddr_offset = 16;
				srcIPAddr_offset = 12;
				is_IP = 1;
				break;
	case ETHERTYPE_ARP :	ether_offset = 14;
				dstIPAddr_offset = 24;
				srcIPAddr_offset = 14;
				break;
	case ETHERTYPE_REVARP :	ether_offset = 14;
				dstIPAddr_offset = 24;
				srcIPAddr_offset = 14;
				break;
	case ETHERTYPE_IPV6:	return NOT_SUPPORTED;
				break;
	
	default :		return NOT_SUPPORTED;
				break;


    }

    ptrToIPAddr = (u_char*)(Buffer + ether_offset + dstIPAddr_offset);
    dstIP = *(unsigned int*)(ptrToIPAddr);

    ptrToSrcIPAddr = (u_char*)(Buffer + ether_offset + srcIPAddr_offset);
    srcIP = *(unsigned int*)(ptrToSrcIPAddr);
    /*
    iph = (struct iphdr *)(Buffer  + sizeof(struct ethhdr) );
    iphdrlen =iph->ihl*4;
     
    memset(&source, 0, sizeof(source));
    source.sin_addr.s_addr = iph->saddr;
     
    memset(&dest, 0, sizeof(dest));
    dest.sin_addr.s_addr = iph->daddr;

    memset(src_ip,0,sizeof(src_ip));
    memset(dst_ip,0,sizeof(dst_ip));

    sprintf(src_ip,"%s",inet_ntoa(source.sin_addr));
    sprintf(dst_ip,"%s",inet_ntoa(dest.sin_addr));
    
    printf("Here\n");
    */
    
    memset(src_ip,0,sizeof(src_ip));
    memset(dst_ip,0,sizeof(dst_ip));

    inet_ntop(AF_INET, &dstIP,dst_ip,sizeof(dst_ip));
    inet_ntop(AF_INET, &srcIP,src_ip,sizeof(src_ip));

    if(is_IP){
	return IP;
    }
	
    return NOT_IP;

}


/* callback function that is passed to pcap_loop(..) and called each time 
 * a packet is recieved                                                    */
void my_callback(const struct pcap_pkthdr* pkthdr,const u_char*  packet,FILE* fp)
{
    
    time_stamp entry;
    //struct timeval tv;
    int size = pkthdr->len;
    int result;
    unsigned short *payload;
    u_char * packet_copy;
    struct iphdr *iph; 
    struct udphdr *udphdrp;
    int ether_offset = 14;
    int should_buffer = TRUE;
    u_short udp_src_port;

    
    //entry.secs = tv.tv_sec;
    //entry.u_secs = tv.tv_usec;
    //entry.n_secs = 0;
    //entry.is_read = 0;
    entry.secs = pkthdr->ts.tv_sec;
    entry.u_secs = pkthdr->ts.tv_usec; 
    entry.n_secs = 0;
    entry.is_read = 0;
    result = get_ip_addresses(packet,size);
    

    switch(result){
	case NOT_SUPPORTED : 	
				return;				
				break;
	case NOT_IP :
				break;

	case IP :		
					
				//packet_copy = (u_char *)malloc(size*sizeof(char));
				//memcpy(packet_copy, packet ,size);		
				packet_copy = (u_char *) packet;
				iph = (struct iphdr *)(packet_copy  + sizeof(struct ethhdr) );
				payload = (unsigned short*) (packet_copy + ether_offset + 20);
				
				break;
	default	:		return;
				break;


    }

   
    
    
    if(strcmp(dev_ip_address,src_ip) == 0){
	
	     fprintf(fp,"Src Ip = %s, Dst Ip = %s\n",src_ip,dst_ip);
		
	     

		
	     if(result == IP){
		compute_ip_checksum(iph);
		switch(iph->protocol){
			case IPPROTO_TCP :	compute_tcp_checksum(iph,payload,fp);
				                entry.pkt_hash_code = (long)packet_hash(packet_copy,size);
  					        //print_packet(packet_copy,size,fp);
						//free(packet_copy);
						fprintf(fp,"Protocol Type : TCP\n");
						break;
			case IPPROTO_UDP :	
						udphdrp = (struct udphdr*)(payload);				                
						udp_src_port = ntohs(udphdrp->source);
						if (udp_src_port == 68){
							should_buffer = FALSE;
						}
						else{
							compute_udp_checksum(iph,payload,fp);
							entry.pkt_hash_code = (long)packet_hash(packet_copy,size);
						}
						
						
  					        //print_packet(packet_copy,size,fp);
						//free(packet_copy);
						fprintf(fp,"Protocol Type : UDP\n");
						break;
			default :		
					        //print_packet((u_char*)packet,size,fp);				                
						//free(packet_copy);
						entry.pkt_hash_code = -1;
						fprintf(fp,"Protocol Type : Other\n");
						break;
		}
	     }
	     else{
	        //print_packet((u_char*)packet,size,fp);
                entry.pkt_hash_code = (long)packet_hash((u_char*)packet,size);
		fprintf(fp,"Protocol Type : Not IP\n");
	     }
	     if(should_buffer)	{
		     sem_wait(&buffer_ptr->empty);
		     sem_wait(&buffer_ptr->mutex);
    		     	     	     
		     fprintf(fp,"Buffering : secs = %d, u_secs = %d, n_secs = %d, pkt_hash_code = %d, size = %d\n",entry.secs,entry.u_secs,entry.n_secs,entry.pkt_hash_code,size);
		     put(buffer_ptr,&entry);
		
		     sem_post(&buffer_ptr->mutex);
	 	     sem_post(&buffer_ptr->full);
	    }

    }


}

pcap_t* producer_init(FILE* fp){

	int found = 0;
        pcap_if_t *alldevs;
	pcap_if_t *d;
	pcap_addr_t *a;
	pcap_t* descr;
	dev_name = "eth0";
	int status = pcap_findalldevs(&alldevs, errbuf);
	if(status != 0) {
	        fprintf(fp,"%s\n", errbuf);
	        return NULL;
   	}
	for(d =alldevs; d!=NULL; d=d->next) {
   	        fprintf(fp,"%s:", d->name);
		if(strcmp(d->name,dev_name) == 0){
		       fprintf(fp,"Device found\n");
 		       for(a = d->addresses; a!=NULL; a=a->next) {
 		           if(a->addr->sa_family == AF_INET){
 		               sprintf(dev_ip_address,"%s", inet_ntoa(((struct sockaddr_in*)a->addr)->sin_addr));
 		               found = 1;
			       break;
				
			    }
 		       }
 	       
	       }
	       printf("\n");
 	}
        if(found == 0 ){
		fprintf(fp,"Device not found or IP address not defined for device. Run as root.\n");
		return NULL;
 	}

        pcap_freealldevs(alldevs);
        fprintf(fp,"Device ip address: %s\n",dev_ip_address);

	/* open device for reading */
 	descr = pcap_open_live(dev_name,BUFSIZ,0,-1,errbuf);
	if(descr == NULL)
	{ 
		fprintf(fp,"pcap_open_live(): %s\n",errbuf); 
		return NULL; 
	}
	return descr;
 
}

int run(pcap_t * descr, FILE* fp){	
	
	struct pcap_pkthdr *header;
	const u_char  *packet;
	int res;

	/* allright here we call pcap_loop(..) and pass in our callback function */
	/* int pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)*/
   
	//pcap_loop(descr,MAX_NO_OF_ENTRIES,my_callback,NULL);
	
	while(1){
		
		res = pcap_next_ex(descr, &header, &packet);
		
		if (res == 0) // Timeout expired. Retry. Examine stop condition.
		{
			if(sem_trywait(&buffer_ptr->stop) == 0) // Check if stop semaphore was set.
			{
				fprintf(fp,"Stopping producer ..\n");
				return 1;
			}
			
			continue;
		}
		if (res == -1) // Error 
		{
			fprintf(fp,"Error reading the packets: %s\n", pcap_geterr(descr));
			return -1;
		}
		else{
			gettimeofday(&tv,0);    
			my_callback(header,packet,fp);

		}
	}

	fprintf(fp,"\nDone processing packets\n");

	return 1;

}

